# 计算机网络相关

## 缓存控制

### 缓存控制流程

1. 浏览器发起请求时，先会查询Cache-Control（Expires设置绝对过期时间，Cache-Control设置相对过期时间，以后者为主）判断过期，如果未过期，则直接读取浏览器缓存文件，不发送HTTP请求
2. 判断上次文件返回头中是否含有Etag信息，有则带上If-None-Match字段信息发送请求给服务器，服务器判断Etag未修改则返回304，如果修改则返回200，否则进入下一步
3. 在浏览器端判断上次文件返回头是否含有Last-Modified信息，有则带上If-Modified-Since字段发送请求，服务端判断Last-Modified失效则返回200，有效则返回304
4. Etag和Last-Modified都不存在则直接向服务器请求

### 304缓存，有了Last-Modified，为什么还要用ETag？有了Etag，为什么还要用Last-Modified？Etag一般怎么生成？

有了Last-Modified，为什么还要用ETag？
（1）因为如果在一秒钟之内对一个文件进行两次更改，Last-Modified就会不正确。
（2）某些服务器不能精确的得到文件的最后修改时间。
（3）一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET。
有了Etag，为什么还要用Last-Modified？
因为有些时候 ETag 可以弥补 Last-Modified 判断的缺陷，但是也有时候 Last-Modified 可以弥补 ETag 判断的缺陷，比如一些图片等静态文件的修改，如果每次扫描内容生成 ETag 来比较，显然要比直接比较修改时间慢很多。所有说这两种判断是相辅相成的。

ETag的值是服务端对文件的索引节，大小和最后修改时间进行Hash后得到的。

[Cache-Control](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control)

## 状态码

HTTP 响应状态代码指示特定 [HTTP](https://developer.mozilla.org/zh-cn/HTTP) 请求是否已成功完成。响应分为五类：信息响应(`100`–`199`)，成功响应(`200`–`299`)，重定向(`300`–`399`)，客户端错误(`400`–`499`)和服务器错误 (`500`–`599`)。状态代码由 [section 10 of RFC 2616](https://tools.ietf.org/html/rfc2616#section-10)定义

[MDN:HTTP 响应代码](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status)

## HTTP 1

* 长连接

* 拓展协议切换

  例：在消息头中添加`Connection:Upgrade`和`Upgrade:websocket`表示切换成`WebSocket`协议

##  HTTP 2 

1. 采用完全二进制的格式传输数据，而非HTTP 1.x 的默认文本格式，可以理解为HTTP2是通过流式传输的
2. 采用HPACK压缩传输，用于对HTTP头部做压缩
3. TCP多路复用 HTTP 1.1 也可以通过PipeLine实现，但是是串行传输，多个请求可能被阻塞；TCP复用传输发生在传输层，而keep-alive控制的文件的连接复用是在应用层的
4. 支持传输流的优先级和流量控制机制
5. 支持服务端推送

[合并 HTTP 请求是否真的有意义？](https://www.zhihu.com/question/34401250)

## 计网基础知识

TCP/IP 协议栈是一系列网络协议的总和，是构成网络通信的核心骨架，它定义了电子设备如何连入因特网，以及数据如何在它们之间进行传输。TCP/IP 协议采用4层结构，分别是**应用层、传输层、网络层和链路层**，每一层都呼叫它的下一层所提供的协议来完成自己的需求。

**链路层：对电信号进行分组并形成具有特定意义的数据帧，然后以广播的形式通过物理介质发送给接收方****

**网络层：定义网络地址，区分网段，子网内MAC寻址，对于不同子网的数据包进行路由**

**传输层：定义端口，标识应用程序身份，实现端口到端口的通信，TCP协议可以保证数据传输的可靠性**

**应用层：定义数据格式并按照对应的格式解读数据**

[深入浅出 TCP/IP 协议栈](https://www.cnblogs.com/onepixel/p/7092302.html)

### 网卡，交换机，网桥，路由器，网关工作在OSI模型哪一层

- 网桥：工作在数据链路层，在不同或相同类型的LAN之间存储并转发数据帧，必要时进行链路层上的协议转换。可连接两个或多个网络，在其中传送信息包。
- 交换机：工作在数据链路层，原理等同于多端口网桥。作用是连接数个相同网段的不同主机，减少网内冲突，隔离冲突域。利用存储转发和过滤技术来从物理上分割网段
- 路由器：工作在网络层，在不同的网络间存储并转发分组。可在异种网络之间（即不同类型的局域网互连，局域网与广域网，广域网与广域网）传输数据并进行路径选择，使用专门的软件协议从逻辑上对整个网络进行划分。
- 网关：对高层协议（包括传输层及更高层次）进行转换的网间连接器。允许使用不兼容的协议，比如SPX/IPX和TCP/IP的系统和网络互连。因为协议转换是网关最重要的功能，所以答案是工作在传输层及以上层次。
- 网卡：在物理层上网卡主要是完成物理接口的连接,电信号的传送以及将数据分解为适当大小的数据包之后向网络上发送的功能. 数据链路层功能包括链路建立和拆除，帧定界同步顺序差错控制这些。大多认为主要工作在物理层。

### IP 地址 ::= { <网络号>, <主机号>}  

|                         Class                         | 前缀位 | 网络地址位数 | 剩余的位数 |  网络数   | 每个网络的主机数 |
| :---------------------------------------------------: | :----: | :----------: | :--------: | :-------: | :--------------: |
|                        A类地址                        |   0    |      8       |     24     |    128    |    16,777,214    |
|                        B类地址                        |   10   |      16      |     16     |  16,384   |      65,534      |
|                        C类地址                        |  110   |      24      |     8      | 2,097,152 |       254        |
| D类地址（[群播](https://zh.wikipedia.org/wiki/群播)） |  1110  |    未定义    |   未定义   |  未定义   |      未定义      |
|                    E类地址（保留）                    |  1111  |    未定义    |   未定义   |  未定义   |      未定义      |

IP地址与子网掩码相关联。在数字上，在类A，B和C的开头和结尾处的块最初是为特殊寻址或将来的功能保留的，即0.0.0.0 / 8和127.0.0.0 / 8在以前的A类中保留；128.0.0.0 / 16和191.255.0.0 / 16在以前的B类中保留，但现在可以分配；192.0.0.0 / 24和223.255.255.0 / 24在以前的C类中保留。127.0.0.0 / 8网络是A类网络，但指定用于环回并且无法分配给网络。

255.255.255.255保留为IPv4广播地址。

### TCP为什么需要3次握手与4次挥手

**为什么需要“三次握手”**

在谢希仁著《计算机网络》第四版中讲“三次握手”的目的是“**为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误**”。在另一部经典的《计算机网络》一书中讲“三次握手”的目的是为了解决“网络中存在延迟的重复分组”的问题。

**为什么需要“四次挥手”**

TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机1发出`FIN`报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回`ACK`报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了`FIN`报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。

[“三次握手，四次挥手”你真的懂吗？](https://zhuanlan.zhihu.com/p/53374516)

###在TCP的拥塞控制中，什么是慢开始、拥塞避免、快重传和快恢复算法?这里每一种算法各起什么作用? “乘法减小”和“加法增大”各用在什么情况下?

答：慢开始： 在主机刚刚开始发送报文段时可先将拥塞窗口cwnd设置为一个最大报文段MSS的数值。在每收到一个对新的报文段的确认后，将拥塞窗口增加至多一个MSS的数值。用这样的方法逐步增大发送端的拥塞窗口cwnd，可以分组注入到网络的速率更加合理。 

拥塞避免： 当拥塞窗口值大于慢开始门限时，停止使用慢开始算法而改用拥塞避免算法。拥塞避免算法使发送的拥塞窗口每经过一个往返时延RTT就增加一个MSS的大小。

快重传算法规定：发送端只要一连收到三个重复的ACK即可断定有分组丢失了，就应该立即重传丢手的报文段而不必继续等待为该报文段设置的重传计时器的超时。

快恢复算法：当发送端收到连续三个重复的ACK时，就重新设置慢开始门限 ssthresh与慢开始不同之处是拥塞窗口 cwnd 不是设置为 1，而是设置为ssthresh若收到的重复的AVK为n个（n>3），则将cwnd设置为ssthresh若发送窗口值还容许发送报文段，就按拥塞避免算法继续发送报文段。若收到了确认新的报文段的ACK，就将cwnd缩小到ssthresh

乘法减小：是指不论在慢开始阶段还是拥塞避免阶段，只要出现一次超时（即出现一次网络拥塞），就把慢开始门限值 ssthresh 设置为当前的拥塞窗口值乘以 0.5。当网络频繁出现拥塞时，ssthresh 值就下降得很快，以大大减少注入到网络中的分组数。加法增大：是指执行拥塞避免算法后，在收到对所有报文段的确认后（即经过一个往返时间），就把拥塞窗口 cwnd增加一个 MSS 大小，使拥塞窗口缓慢增大，以防止网络过早出现拥塞

[【网络协议】TCP分段与IP分片](https://blog.csdn.net/ns_code/article/details/30109789)

## 操作系统相关

Linux进程状态转换

TASK_RUNNING : 就绪态或者运行态，进程就绪可以运行，但是不一定正在占有CPU，对应进程状态的R

TASK_INTERRUPTIBLE:睡眠态，但是进程处于浅度睡眠，可以响应信号，一般是进程主动sleep进入的状态，对应进程状态S

TASK_UNINTERRUPTIBLE:睡眠态，深度睡眠，不响应信号，典型场景是进程获取信号量阻塞，对应进程状态D

TASK_ZOMBIE:僵尸态，进程已退出或者结束，但是父进程还不知道，没有回收时的状态，对应进程状态Z

TASK_STOPED:停止，调试状态，对应进程状态T

![img](https://tva1.sinaimg.cn/large/00831rSTgy1gd0syhmflbj30pd0esabz.jpg)